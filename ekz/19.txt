параллельное программирование на Python. Multiprocessing
https://geekbrains.ru/posts/python_threading_part1
	это библиотека для управления процессами
	
	Создаем потоки:
		Метод 1  — «функциональный»
			Для работы с потоками из модуля threading импортируем класс Thread. В начале кода пишем:
			
			from threading import Thread
			После этого нам будет доступна функция Thread()  — с ней легко создавать потоки. Синтаксис такой:
			
			variable = Thread(target=function_name, args=(arg1, arg2,))
			Первый параметр target — это «целевая» функция, которая определяет поведение потока и создаётся заранее. Следом идёт список аргументов. Если судьбу аргументов (например, кто будет делимым, а кто делителем в уравнении) определяет их позиция, их записывают как args=(x,y). Если же вам нужны аргументы в виде пар «ключ-значение», используйте запись вида kwargs={‘prop’:120}.
			
			Ради удобства отладки можно также дать новому потоку имя. Для этого среди параметров функции прописывают name=«Имя потока». По умолчанию name хранит значение null. А ещё потоки можно группировать с помощью параметра group, который по умолчанию — None.
			
			За дело! Пусть два потока параллельно выводят каждый в свой файл заданное число строк. Для начала нам понадобится функция, которая выполнит задуманный нами сценарий. Аргументами целевой функции будут число строк и имя текстового файла для записи.
			
			Давайте попробуем:
			
			#coding: UTF-8
			from threading import Thread
			
			def prescript(thefile, num):
				with open(thefile, 'w') as f:
					for i in range(num):
						if num > 500:
							f.write('МногоБукв\n')
						else:
							f.write('МалоБукв\n')
			
			thread1 = Thread(target=prescript, args=('f1.txt', 200,))
			thread2 = Thread(target=prescript, args=('f2.txt', 1000,))
			
			thread1.start()
			thread2.start()
			thread1.join()
			thread2.join()
			
	start() запускает ранее созданный поток
	Метод join() останавливает поток, когда тот выполнит свои задачи. В качестве параметра в скобках можно указать, на сколько секунд блокировать поток перед продолжением его работы.
	
	Для потока со сложным поведением обычно пишут отдельный класс, который наследуют от Thread из модуля threading. В этом случае программу действий потока прописывают в методе run() созданного класса.
	
	import threading
	class MyThread(threading.Thread):
		def __init__(self, num):
			super().__init__(self, name="threddy" + num)
			self.num = num
		def run(self):
			print ("Thread ", self.num),
	thread1 = MyThread("1")
	thread2 = MyThread("2")
	thread1.start()
	thread2.start()
	thread1.join()
	thread2.join()
	
	Чтобы управлять потоками, нужно следить, как они себя ведут. И для этого в threading есть специальные методы:

	current_thread()  — смотрим, какой поток вызвал функцию;
	
	active_count() — считаем работающие в данный момент экземпляры класса Thread;
	
	enumerate()   — получаем список работающих потоков.
	
	Ещё можно управлять потоком через методы класса:
	
	is_alive()  —  спрашиваем поток: «Жив ещё?»  — получаем true или false;
	
	getName()  — узнаём имя потока;
	
	setName(any_name)  — даём потоку имя;
	
	