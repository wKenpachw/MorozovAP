17) модульное тестирование
неплохая статья : https://habr.com/ru/company/mailru/blog/418929/
наш пример: https://github.com/wKenpachw/MorozovAP/blob/master/fourthlab/atribute_test.py
Цели модульного тестирования:
	1)регрессия: поправить что-нибудь в коде, запустить тесты и узнать, что ничего не сломалось

	2)оценить влияние архитектуры
	Если в проекте вы вводите обязательное модульное тестирование, или просто договариваетесь с разработчиками о применении модульных тестов, это немедленно отразится на стиле написания кода
	Невозможно писать функции на 300 строк с 50 локальными переменными и 15 параметрами, если эти функции будут подвергаться модульному тестированию
	Кроме того, благодаря этим тестам станут понятнее интерфейсы и проявятся какие-то проблемные места
	Ведь если код не ахти, то и тест будет кривой, и это сразу бросится в глаза
	
	3)сделать код понятнее
	Допустим, вы пришли в новый проект и вам дали 50 Мб исходников
	Возможно, вы просто не сможете в них разобраться
	Если модульных тестов нет, то единственный способ познакомиться с работой кода, помимо чтения исходников, это «метод тыка»
	Но если система достаточно сложная, то чтобы добраться через интерфейс до нужных кусков кода, может понадобиться много времени
	А благодаря модульным тестам вы можете посмотреть, как код исполняется из любого места.
	
	4)упростить отладку. К примеру, вы нашли какой-то класс и хотите его отладить. Если вместо модульных тестов есть только системные, или вообще никаких тестов нет, то остается только добираться до нужного места через интерфейс.
	
	5)комфорт
	Могу взять незнакомый исходник, поправить три строки, запустить тесты и убедиться, что код работает, как задумано. И речь даже не о том, чтобы тесты были зелеными: они могут быть и красными, но именно там, где я ожидаю. То есть я понимаю, как работает код.
	
Реализация на Python:
	Мы используем стандартную библиотеку unittest из семейства xUnit.
	Модульный тест — это обычный код, которому присуща некая стандартная архитектура. Все модульные тесты состоят из трех этапов: setup, exercise и verify. Вы подготавливаете данные, запускаете тесты и смотрите, всё ли пришло в нужное состояние.
	
	Setup:
		Самый сложный и интересный этап. Привести систему в изначальное состояние, из которого вы хотите её тестировать, может быть очень непросто. А состояние системы может быть сколь угодно сложным.
		
	exercise:
		Про этот этап рассказывать особо нечего. Единственное, что здесь может пойти не так, — это обращение вовне, например, в интернет.
		
	Verify:
		На этом этапе мы активно используем самописные assert’ы, даже однострочные
		
		
	unittest:
		пишем какой-то класс, функцию, что угоно, что хотим проверить
		далее создаем файл для тестирования, импортируем написанный код и создаем класс сеттирования, унаследованный от unittest.TestCase
		в нем должен вызываем методы для тестирования	
			1)assertEqual - метод сравненивает то, что мы хотим получить с тем, что мы получаем используя наш первый класс:
				self.assertEqual(result(то, что получим используя наш первый класс, value (ожидаемое значение)
				при совпадении результатов тест будет пройден успешно
			2) assertNotEqual - тоже самое, но успешно, когда значения расходятся
			
			3) assertTrue  и assertFalse - когда ожидаем True или False
			
			4)assertIs и assertIsNot  - сравниваем два результата (скорее всего две сущности, а не значения) и сравниваем их
			
			5) assertIsNone и assertIsNotNone - получаем None или не None
			
			их ещё много всяких, но больше мы точно не проходили.
		